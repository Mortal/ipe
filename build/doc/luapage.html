<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Ipelib: Lua bindings for Document, Page, and StyleSheet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Ipelib</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">The Ipe library documentation</a>      </li>
      <li class="navelem"><a class="el" href="lua.html">Programming in Lua</a>      </li>
</div>
<div class="header">
  <div class="headertitle">
<h1>Lua bindings for Document, Page, and StyleSheet </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="luastyle"></a>
Stylesheet</h2>
<p>A stylesheet can be constructed by reading from a file (in XML format), or by creating an empty stylesheet: </p>
<div class="fragment"><pre class="fragment">
sheet = ipe.Sheet("filename")
-- returns sheet or nil, error message
sheet = ipe.Sheet()    -- empty stylesheet
</pre></div><p>Stylesheets have the following methods: </p>
<div class="fragment"><pre class="fragment">
sheet:clone()            -- returns a private copy of the stylesheet
sheet:xml(with_bitmaps)  -- return XML representation 
sheet:add(kind, symbolic, value)
sheet:set(kind, value)
sheet:isStandard()      -- is this the built-in stylesheet?
sheet:name()            -- name of the stylesheet
sheet:setName(name)
</pre></div><p><code>sheet:add</code> adds a definition for symbolic name to the stylesheet. Permissible values for <code>kind</code> are: </p>
<div class="fragment"><pre class="fragment">
 pen, symbolsize, arrowsize, color, dashstyle, textsize, textstretch, 
 textstyle, gridsize, anglesize, opacity, symbol, 
</pre></div><p><code>sheet:set</code> sets a value. Permissible values for <code>kind</code> are: </p>
<div class="fragment"><pre class="fragment">
 preamble, linecap, linejoin, fillrule
</pre></div><h2><a class="anchor" id="luacascade"></a>
Stylesheet cascade</h2>
<p>Documents own an entire stack of style sheets, the style sheet <em>cascade</em>. An empty style sheet cascade can be created like this: </p>
<div class="fragment"><pre class="fragment">
sheets = ipe.Sheets()
</pre></div><p> or you can obtain one from an Ipe document.</p>
<p>Style sheet cascades have the following methods: </p>
<div class="fragment"><pre class="fragment">
sheets1 = sheets:clone()              -- make a private copy
sheets:allNames(kind)
sheets:find(kind, symbolic)
sheets:has(kind, symbolic)
sheets:count()                        -- return number of sheets
sheets:sheet(index)                   -- return sheet at index
sheets:insert(index, style_sheet)     -- insert sheet at index
sheets:remove(index)                  -- delete a sheet
log = sheets:update(directory)        -- update style sheets from directory
</pre></div><p><code>sheets:allNames</code> returns a table with all symbolic names defined in the entire stylesheet cascade. Permissible values for <code>kind</code> are: </p>
<div class="fragment"><pre class="fragment">
 pen, symbolsize, arrowsize, color, dashstyle, textsize, textstretch, 
 textstyle, gridsize, anglesize, opacity, tiling, symbol, gradient, effect
</pre></div><p><code>sheet:has</code> checks whether a symbolic name is defined in the cascade. Permissible values for <code>kind</code> are as for <code>allNames</code>.</p>
<p><code>sheet:find</code> looks up a symbolic definition. Permissible values for <code>kind</code> are: </p>
<div class="fragment"><pre class="fragment">
 pen, symbolsize, arrowsize, color, dashstyle, textsize, textstretch, 
 textstyle, gridsize, anglesize, opacity, symbol, 
 preamble, linecap, linejoin, fillrule, layout
</pre></div><h2><a class="anchor" id="luapage1"></a>
Page</h2>
<p>Page objects can be created like this: </p>
<div class="fragment"><pre class="fragment">
p = ipe.Page()   -- create basic page with one layer and one view
p1 = p:clone()   -- returns a copy of the page
</pre></div><p>The following methods act on the <b>views</b> of a page. Note that views are indexed starting from 1, as usual in Lua. </p>
<div class="fragment"><pre class="fragment">
p:countViews() 
p:effect(view)
p:setEffect(view, effect)
p:active(view)
p:setActive(view, layer)
p:insertView(view, layer)
p:removeView(view)
p:clearViews()
f = p:viewMarked(view) -- return true/false
p:setViewMarked(view, f)
</pre></div><p>The following methods act on the <b>layers</b> of a page. Note that layers are always accessed by name, not by index as in C++. </p>
<div class="fragment"><pre class="fragment">
p:countLayers()
p:layers()        -- return table of layer names
p:isLocked(layer)
p:setLocked(layer)
p:hasSnapping(layer)
p:setSnapping(layer)
p:renameLayer(oldname, newname)
p:addLayer(name)     -- or create name if nil (name is returned)
p:removeLayer(layer)
p:moveLayer(layer, target_index)
p:visible(view, layer)   -- is layer visible in view?
p:setVisible(view, layer, boolean)
</pre></div><p>The <b>objects</b> of a page can be accessed by indexing, using an iterator, or with various methods. Note that object indices start with 1, as usual in Lua. </p>
<div class="fragment"><pre class="fragment">
-- objects:

#p      -- return number of objects on page
p[i]    -- return object #i, where 1 &lt;= i &lt;= #p

-- iterate over objects of page:
for i, obj, sel, layer in p:objects() do
  print(i, obj, sel, layer)
end

p:select(objno)              -- returns nil, 1, or 2
p:setSelect(objno, status)   -- status is nil, 1, or 2
p:layerOf(objno)
p:setLayerOf(objno, layer)
p:visible(view, objno)       -- is object visible in view?
p:bbox(objno)                -- cached by page
p:invalidateBBox(objno)      -- invalidate cached bbox
p:insert(objno, object, select, layer)  -- objno == nil means append
p:remove(objno)
p:replace(objno, object)     -- automatically clones object
p:transform(objno, matrix)

-- returns true if attribute was actually changed
p:setAttribute(objno, property, value, stroke, fill) 
</pre></div><p>Finally, there are various methods to query and modify the currently selected objects, the page title and sections, etc.: </p>
<div class="fragment"><pre class="fragment">
-- selection:
obj = p:primarySelection() -- nil if no primary selection
p:hasSelection()           -- true or false
p:deselectAll()
p:ensurePrimarySelection()

-- t is a table with fields "title", "section", "subsection"
-- if section or subsection is not a string, the title is used 
t = p:titles()  
p:setTitles(t)

-- n is a string
n = p:notes()
p:setNotes(n)

-- f is true/false
f = p:marked()
p:setMarked(f)

-- misc:
rect = p:textBox(sheets)   -- box for next text box
</pre></div><h2><a class="anchor" id="luadoc"></a>
Document</h2>
<p>Documents have the following methods: </p>
<div class="fragment"><pre class="fragment">
doc = ipe.Document()         -- empty document
doc = ipe.Document(filename) -- load from file 
-- returns either document or nil, error message, error code

#doc    -- number of pages
doc[i]  -- return page #i, where 1 &lt;= i &lt;= #doc

-- format == nil: guess from filename
-- flags is either nil, or a table with keys
-- "export", "nozip", "lastview", "nocolor"
doc:save(filename, format, flags)  
doc:exportPages(filename, flags, fromPage, toPage)
doc:exportView(filename, format, flags, pageNo, viewNo)

-- iterating over pages of document:
for i, p in doc:pages() do
  print("Page number",  i, p)
end

doc:set(no, page)         -- replace with a clone of page, returns old page
doc:insert(no, page)
doc:append(page)
doc:remove(no)            -- returns page and removes from document
doc:countTotalViews()
doc:sheets()              -- returns style sheet cascade
old = doc:replaceSheets(sheets)  -- replace and return old cascade
doc:has(what)  -- where what in { "truetype", "gradients", "tilings", "transparency" }
doc:runLatex()
-- returns either true, nil, result code, logfile
--         or     false, error message, result code, logfile

doc:fontPool()    -- returns light userdata
doc:checkStyle()  -- returns list of undefined symbolic names
t = doc:properties()  -- returns table
doc:setProperties(t)  -- changes properties set in table
</pre></div><p><code>doc:properties()</code> returns a table with the following fields (all fields exist even if their contents is an empty string): </p>
<div class="fragment"><pre class="fragment">
title author subject keywords preamble created modified creator
fullscreen cropbox numberpages 
</pre></div><h2><a class="anchor" id="luaother"></a>
Other functions</h2>
<div class="fragment"><pre class="fragment">
ipe.fileFormat(filename)      -- returns one of "xml", "pdf", "eps", "ipe5", "unknown"
ipe.fileExists(filename)      -- returns true or false
beziers = ipe.splineToBeziers(spline, is_closed)
ipelet = ipe.Ipelet(dllname)  -- loads C++ ipelet from absolute path
-- returns ipelet or nil, error message
</pre></div> </div></div>
<hr>
</body></html>
