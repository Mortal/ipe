<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Ipelib: Lua bindings for geometric objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">The Ipe library documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="lua.html">Programming in Lua</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="luageo">Lua bindings for geometric objects </a></h1>All Ipelib objects have constructors of the form:<p>
<div class="fragment"><pre class="fragment">
 v = ipe.Vector()
 m = ipe.Matrix()
 m = ipe.Translation()  -- another Matrix constructor
 m = ipe.Rotation()     -- yet another Matrix constructor
 r = ipe.Rect()
 l = ipe.Line()
 l = ipe.LineThrough()  -- another Line constructor
 l = ipe.Bisector()     -- yet another Line constructor
 s = ipe.Segment()
 b = ipe.Bezier()
 a = ipe.Arc()
</pre></div><p>
Note that <a class="el" href="classipe_1_1_angle.html" title="A double that&#39;s an angle.">ipe::Angle</a> and <a class="el" href="classipe_1_1_linear.html" title="Linear transformation in the plane (2x2 matrix).">ipe::Linear</a> are not bound in Lua. Use numbers and <a class="el" href="classipe_1_1_matrix.html" title="Homogeneous transformation in the plane.">ipe.Matrix</a> instead. A useful method for angles is: <div class="fragment"><pre class="fragment">
beta = ipe.normalizeAngle(alpha, lowLimit)
</pre></div><h2><a class="anchor" name="luavector">
Vector</a></h2>
<em><a class="el" href="classipe_1_1_vector.html" title="Two-dimensional vector.">ipe.Vector</a></em> binds <a class="el" href="classipe_1_1_vector.html" title="Two-dimensional vector.">ipe::Vector</a>. There are the following methods: <div class="fragment"><pre class="fragment">
v = ipe.Vector()         -- zero vector
v = ipe.Vector(x, y)
v = ipe.Direction(alpha) -- unit vector in this direction 
a = v.x                  -- read only access to x and y coordinates
b = v.y

v:len() -- returns norm of vector
v:sqLen() -- returns square of norm
v:normalized() -- returns this vector normalized
v:orthogonal() -- returns this vector rotated left by 90 degrees
v:factorize(u) -- factors v = lambda u + x, where x orth. to u, u is unit
v:angle()     -- return direction 
v == w        -- vector equality
v ~= w
-v            -- unary minus
v + w         -- vector addition
v - w         -- vector difference
5 * v         -- multiplication with a scalar
v * 5         -- multiplication with a scalar
v .. w        -- dot product
</pre></div><h2><a class="anchor" name="luamatrix">
Matrix</a></h2>
<em><a class="el" href="classipe_1_1_matrix.html" title="Homogeneous transformation in the plane.">ipe.Matrix</a></em> binds <a class="el" href="classipe_1_1_matrix.html" title="Homogeneous transformation in the plane.">ipe::Matrix</a>. It has the following methods: <div class="fragment"><pre class="fragment">
m = ipe.Matrix()                        -- identity matrix
m = ipe.Matrix(a1, a2, a3, a4)		-- linear transformation
m = ipe.Matrix(a1, a2, a3, a4, a5, a6)  -- affine transformation
m = ipe.Matrix( { a1, a2, a3, a4, a5, a6 } ) -- same from table
m = ipe.Rotation(alpha)                 -- rotation matrix
m = ipe.Translation(v)                  -- v is a vector
m = ipe.Translation(x, y)

m1 == m2          -- matrix equality
m1 * m2           -- matrix multiplication
m * v             -- matrix * vector
m * arc		  -- matrix * arc

m:elements()      -- returns six-element array with elements

m:isIdentity()
m:isSingular()
m:inverse()
m:translation()   -- return translation component
m:linear()        -- returns matrix without the translation component
</pre></div><h2><a class="anchor" name="luarect">
Rect</a></h2>
<em><a class="el" href="classipe_1_1_rect.html" title="Axis-parallel rectangle (which can be empty).">ipe.Rect</a></em> binds <a class="el" href="classipe_1_1_rect.html" title="Axis-parallel rectangle (which can be empty).">ipe::Rect</a>. This is the only mutable geometric object - take care not to be surprised when <em><a class="el" href="classipe_1_1_rect.html" title="Axis-parallel rectangle (which can be empty).">ipe.Rect</a></em> objects are shared.<p>
It has the following methods: <div class="fragment"><pre class="fragment">
r = ipe.Rect()    -- empty
r:isEmpty()
r:topRight()
r:bottomLeft()
r:topLeft()
r:bottomRight()
r:left()
r:right()
r:bottom()
r:top()
r:width()
r:height()
r:add(v)          -- extend to cover vector v
r1:add(r2)        -- extend to cover rectangle r2
r1:clipTo(r2)     -- clip r1 to lie inside r2
r:contains(v)     
r1:contains(r2)
r1:intersects(r2)
</pre></div><h2><a class="anchor" name="lualine">
Line</a></h2>
<em><a class="el" href="classipe_1_1_line.html" title="A directed line.">ipe.Line</a></em> binds <a class="el" href="classipe_1_1_line.html" title="A directed line.">ipe::Line</a>. It has the following methods:<p>
<div class="fragment"><pre class="fragment">
l = ipe.Line(p, dir)      -- dir must be unit vector
l = ipe.LineThrough(p, q)
l = ipe.Bisector(p, q)

-- l:side() returns +1 if v lies to the left side of the line, 
-- 0 if on line, -1 if on the right side
l:side(v)                 
l:point()                 -- starting point of line
l:dir()                   -- unit direction vector
l:normal()                -- unit normal vector pointing to the left side
l:distance(v)             -- returns distance from point to line
l1:intersects(l2)         -- returns intersection point or nil
l:project(p)              -- projection of point on line
</pre></div><h2><a class="anchor" name="luasegment">
Segment</a></h2>
<em><a class="el" href="classipe_1_1_segment.html" title="A directed line segment.">ipe.Segment</a></em> binds <a class="el" href="classipe_1_1_segment.html" title="A directed line segment.">ipe::Segment</a>. It has the following methods:<p>
<div class="fragment"><pre class="fragment">
s = ipe.Segment(p, q)	
p, q = s:endpoints()      -- returns both endpoints
s:line()                  -- returns an ipe.Line
s:project(p)              -- returns projection or nil
s:distance(p)
s:intersects(l)           -- return intersection point or nil
s1:intersects(s2)
</pre></div><h2><a class="anchor" name="luabezier">
Bezier</a></h2>
<em><a class="el" href="classipe_1_1_bezier.html" title="A cubic Bezier spline.">ipe.Bezier</a></em> binds <a class="el" href="classipe_1_1_bezier.html" title="A cubic Bezier spline.">ipe::Bezier</a>. It has the following methods:<p>
<div class="fragment"><pre class="fragment">
b = ipe.Bezier(v1, v2, v3, v4)	
b:point(t)                -- point at value t
v1, v2, v3, v4 = b:controlpoints()  -- returns all four control points
b:bbox()
t, p = b:snap(pos)
b:intersects(s)           -- return intersection point or nil
b:intersects(l)
</pre></div><h2><a class="anchor" name="luaarc">
Arc</a></h2>
<em><a class="el" href="classipe_1_1_arc.html" title="An arc of an ellipse.">ipe.Arc</a></em> binds <a class="el" href="classipe_1_1_arc.html" title="An arc of an ellipse.">ipe::Arc</a>. It has the following methods:<p>
<div class="fragment"><pre class="fragment">
a = ipe.Arc(m)            -- ellipse defined by ipe.Matrix m
a = ipe.Arc(m, p, q)      -- arc from p to q
a = ipe.Arc(m, alpha, beta)

a:endpoints()             -- returns two endpoints
a:angles()                -- returns two angles
a:bbox()
a:matrix()
a:isEllipse() 
alpha, p = a:snap(pos)
a:intersects(s)           -- return intersection point or nil
a:intersects(l)
</pre></div> </div>
<hr>
</body></html>
