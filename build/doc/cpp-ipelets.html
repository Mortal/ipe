<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Ipelib: Ipelets written in C++</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="index.html">The Ipe library documentation</a>&nbsp;&raquo&nbsp;<a class="el" href="ipelets.html">Ipelets</a>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="cpp-ipelets">Ipelets written in C++ </a></h1>As in Ipe 6, it is possible to write ipelets entirely in C++. Different from Ipe 6, however, the labels of the ipelet and its functions must now be specified in a short Lua wrapper with some boilerplate code. This Lua code will invoke your C++ methods.<h2><a class="anchor" name="cpp-framework">
C++ ipelet framework</a></h2>
The C++ code is in a dynamically loaded library (DLL), that you place on Ipe's C++ ipelet path. The DLL has to be written in C++, and must export a function <code>newIpelet</code> that creates an object derived from the class <code>Ipelet</code> (defined in <em>ipelet.h</em>). Here is a minimal ipelet implementation:<p>
<div class="fragment"><pre class="fragment">
#include "ipelet.h"

class MyIpelet : public ipe::Ipelet {
public:
  virtual int ipelibVersion() const { return IPELIB_VERSION; }
  virtual bool run(int function, ipe::IpeletData *data, ipe::IpeletHelper *helper);
};

bool MyIpelet::run(int function, ipe::IpeletData *data, ipe::IpeletHelper *helper)
{
  // this is where you do all the work
}

IPELET_DECLARE ipe::Ipelet *newIpelet()
{
  return new MyIpelet;
}
</pre></div><p>
When the ipelet is executed, Ipe hands it a structure with some information about the document, in particular a pointer to the current page. The ipelet can examine the selected objects, and modify the page in any way it wishes. (It is not possible to modify the document outside the current page, as this would interfere with the undo stack). It can also request services from the Ipe application through the <code>IpeletHelper</code> object, for instance to display a message in the status bar, to pop up message boxes and to obtain input from the user.<p>
The <em>run</em> method must return <em>true</em> if it modified the document page. This is used to create an item on the undo stack so that this change can be undone. If the <em>run</em> method returns <em>false</em>, then no undo stack item is created. In this case, the ipelet must <b>not</b> modify the page.<h2><a class="anchor" name="wrapper">
The Lua wrapper</a></h2>
You need to provide a small Lua wrapper that declares the names of the ipelet and its methods, and that calls your C++ code when an ipelet method is invoked. This wrapper will look as follows:<p>
<div class="fragment"><pre class="fragment">
-- Lua wrapper for C++ ipelet "myipelet"

label = "My Ipelet"

about = "This ipelet is for explanation only"

-- this variable will store the C++ ipelet when it has been loaded
ipelet = false

function run(ui, num)
  if not ipelet then ipelet = assert(loadIpelet("myipelet"))
  ui:runIpelet(ipelet, mum) 
end

methods = { { label = "First function of my ipelet" },
            { label = "Second function of my ipelet" }
          }
</pre></div><p>
If the ipelet contains only a single method, then the <code>methods</code> table is omitted.<p>
The Lua wrapper needs to be placed in Ipe's ipelet directory. When Ipe starts up, it automatically loads all ipelets from this directory. Note that the wrapper above does not immediately load the C++ ipelet (using <code>loadIpelet</code>) when the Lua wrapper is loaded by Ipe, but only when the first method of the ipelet is called. This is considered good style.<h2><a class="anchor" name="kgon-example">
An example ipelet</a></h2>
<em>Kgon</em> is a minimal ipelet that you can use as the basis for your own development. It defines only a single function, and makes no use of the function argument to <code>run</code>.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// --------------------------------------------------------------------</span>
<span class="comment">// Ipelet for creating regular k-gons</span>
<span class="comment">// --------------------------------------------------------------------</span>

<span class="preprocessor">#include "ipelet.h"</span>
<span class="preprocessor">#include "ipepath.h"</span>
<span class="preprocessor">#include "ipepage.h"</span>

<span class="keyword">using namespace </span>ipe;

<span class="comment">// --------------------------------------------------------------------</span>

<span class="keyword">class </span>KGonIpelet : <span class="keyword">public</span> Ipelet {
<span class="keyword">public</span>:
  <span class="keyword">virtual</span> <span class="keywordtype">int</span> ipelibVersion()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="group__base.html#g63fb9a4c5352670e3c1fa6ae2df310b6" title="Ipelib version.">IPELIB_VERSION</a>; }
  <span class="keyword">virtual</span> <span class="keywordtype">bool</span> run(<span class="keywordtype">int</span>, IpeletData *data, IpeletHelper *helper);
};

<span class="comment">// --------------------------------------------------------------------</span>

<span class="keywordtype">bool</span> KGonIpelet::run(<span class="keywordtype">int</span>, IpeletData *data, IpeletHelper *helper)
{
  Page *page = data-&gt;iPage;
  <span class="keywordtype">int</span> sel = page-&gt;primarySelection();
  <span class="keywordflow">if</span> (sel &lt; 0) {
    helper-&gt;message(<span class="stringliteral">"No selection"</span>);
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }
  <span class="keyword">const</span> Path *p = page-&gt;object(sel)-&gt;asPath();
  <span class="keywordflow">if</span> (p == 0 || p-&gt;shape().countSubPaths() != 1 ||
      p-&gt;shape().subPath(0)-&gt;type() != SubPath::EEllipse) {
    helper-&gt;message(<span class="stringliteral">"Primary selection is not a circle"</span>);
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
  }

  String str;
  <span class="keywordflow">if</span> (!helper-&gt;getString(<span class="stringliteral">"Enter k (number of corners)"</span>, str))
    <span class="keywordflow">return</span> <span class="keyword">false</span>;
  <span class="keywordtype">int</span> k = Lex(str).getInt();
  <span class="keywordflow">if</span> (k &lt; 3 || k &gt; 1000)
    <span class="keywordflow">return</span> <span class="keyword">false</span>;

  <span class="keyword">const</span> Ellipse *e = p-&gt;shape().subPath(0)-&gt;asEllipse();
  Matrix m = p-&gt;matrix() * e-&gt;matrix();
  
  Vector center = m.translation();
  Vector v = m * Vector(1,0);
  <span class="keywordtype">double</span> radius = (v - center).len();

  Curve *sp = <span class="keyword">new</span> Curve;
  <span class="keywordtype">double</span> alpha = 2.0 * IpePi / k;
  Vector v0 = center + radius * Vector(1,0);
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; k; ++i) {
    Vector v1 = center + radius * Vector(Angle(i * alpha));
    sp-&gt;appendSegment(v0, v1);
    v0 = v1;
  }
  sp-&gt;setClosed(<span class="keyword">true</span>);
  Shape shape;
  shape.appendSubPath(sp);
  Path *obj = <span class="keyword">new</span> Path(data-&gt;iAttributes, shape);
  page-&gt;append(<a class="code" href="group__attr.html#gg8c1edaea1ba2aa857409e4bcf52e73bfe93c82417df80bf565dc4ff4e5a0b58f">ESecondarySelected</a>, data-&gt;iLayer, obj);
  helper-&gt;message(<span class="stringliteral">"Created regular k-gon"</span>);
  <span class="keywordflow">return</span> <span class="keyword">true</span>;
}

<span class="comment">// --------------------------------------------------------------------</span>

IPELET_DECLARE Ipelet *newIpelet()
{
  <span class="keywordflow">return</span> <span class="keyword">new</span> KGonIpelet;
}

<span class="comment">// --------------------------------------------------------------------</span>
</pre></div><p>
The Lua wrapper would look like this:<p>
<div class="fragment"><pre class="fragment">----------------------------------------------------------------------
-- kgon ipelet description
----------------------------------------------------------------------

label = <span class="stringliteral">"Regular k-gon"</span>

about = [[
Constructs a regular k-gon from a circle.

This ipelet is part of Ipe.
]]

-- <span class="keyword">this</span> variable will store the C++ ipelet when it has been loaded
ipelet = <span class="keyword">false</span>

function run(model)
  if not ipelet then ipelet = assert(ipe.Ipelet(dllname)) end
  model:runIpelet(label, ipelet) 
end

-- define a shortcut for this function
shortcuts.ipelet_1_kgon = "Alt+Ctrl+K"

----------------------------------------------------------------------
</pre></div><h2><a class="anchor" name="unix-compile">
Compiling ipelets on Unix</a></h2>
The ipelet must be compiled as a shared library and must be linked with the Ipe library ``libipe.so''. C++ mandates that it must be compiled with the same compiler that was used to compile Ipe. Have a look at the ipelet sources in the Ipe source distribution, and their makefiles for details on compiling them.<h2><a class="anchor" name="win-compile">
Compiling ipelets on Windows</a></h2>
The ipelet must be compiled as a DLL and must be linked with the Ipe library ``ipe.dll''. C++ mandates that it must be compiled with the same compiler that was used to compile Ipe. If you use the binary Ipe distribution for Windows, that means you have to use the MinGW compiler. (If you haven't used it before: MinGW is a port of g++ for Windows).<p>
The Ipe Windows distribution contains the necessary header files and the library to compile ipelets, as well as the source of the ``kgon'' and ``goodies'' ipelets as examples. To compile the ``kgon'' example, open a command shell, make sure MinGW g++ is on your path, and say:<p>
<div class="fragment"><pre class="fragment">
  g++ -c -O2 -DWIN32 -fno-exceptions -fno-rtti -Iinclude kgon.cpp
  g++ -Wl,-enable-stdcall-fixup -Wl,-enable-auto-import \
  -Wl,-enable-runtime-pseudo-reloc -Wl,-s -shared -o kgon.dll kgon.o \
  -Llib -lipe
</pre></div><p>
Place the resulting <em>kgon.dll</em> in the <em>ipelets</em> subdirectory, and restart Ipe. </div>
<hr>
</body></html>
